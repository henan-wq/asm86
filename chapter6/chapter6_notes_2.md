# 困惑与问题：
1. 使用补码的方法可以非常迅速地描述负数
    1. 例如我想求十进制值`-1`的二进制
    2. 先将**1**的二进制写出：**0000 0001**
    3. 对其反码：得到**1111 1110**
    4. 对反码结果+1，得到**1111 1111**。这就是`-1`的二进制。
2. 奇偶标志位**PF**
    1. 算数逻辑运算会影响标志寄存器的某些位，如`add`,`xor`
    2. 当运算结果出来后，在低8位中，有偶数个为1的比特，则PF=1；否则PF=0
3. 进位标志**CF**
    - 算术操作时，最高位有向前进位或借位的情况发生，则**CF=1**,否则**CF=0**；
        - 例如：
            1. `mov al 10000000B     ;al <- 0x80`
            2. `add al,al            ;al <-0x80`
    - CF似乎不受`inc`和`dec`指令的影响？
4. 溢出标志**OF**，假定你进行的是有符号运算，如果结果超出了目标操作数所能容纳的范围，OF=1,否则OF=0.
    - 例如：
        1. `mov ah,0xff     ;ah <- -1`
        2. `add ah,2        ;ah <- 1,因为1没有超出8位有符号数-128~+127范围`
        3. 所以OF=0
    - 例如2：
        1. `mov ah,0x70     ;ah <- +112`
        2. `add ah,ah       ;ah <- +224(DEC)=1110 0000(BIN),但因为224超出了8位有符号数的-128~+127范围，所以1110 0000被解读成-32，计算结果也错误了`
        3. 所以OF=1
        4. 如果想解决这类问题，最好用更大范围的目标操作数，如AX寄存器。
5. Bochs可以查看标志位的状态，书中章节6.12.3
6. 条件转移指令必须出现在影响标志的的指令之后。
7. 比较指令`cmp`，会根据计算的结果设置相应的标志位，但不保留计算结果，。该指令需要两个操作数，所以也不会改变两个操作数的内容；
    - `cmp`指令将会影响CF,OF,SF,ZF,AF和PF标志位。
    - 目的操作数可以是8位或16位通用寄存器，也可以是8位或16位内存单元
    - 源操作数可以是与目的操作数宽度一致的通用寄存器、内存单元或立即数，但两个操作数同时作为内存单元的情况除外
8. `jcxz`（jump if CX is zero），意思是CX寄存器内容为0时则转移。执行这条指令时，处理器先测试寄存器CX是否为0，例如：
    - `jcxz show`