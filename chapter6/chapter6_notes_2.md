# 困惑与问题：
1. 使用补码的方法可以非常迅速地描述负数
    1. 例如我想求十进制值`-1`的二进制
    2. 先将**1**的二进制写出：**0000 0001**
    3. 对其反码：得到**1111 1110**
    4. 对反码结果+1，得到**1111 1111**。这就是`-1`的二进制。
2. 奇偶标志位**PF**
    1. 算数逻辑运算会影响标志寄存器的某些位，如`add`,`xor`
    2. 当运算结果出来后，在低8位中，有偶数个为1的比特，则PF=1；否则PF=0
3. 进位标志**CF**
    - 算术操作时，最高位有向前进位或借位的情况发生，则**CF=1**,否则**CF=0**；
        - 例如：
            1. `mov al 10000000B     ;al <- 0x80`
            2. `add al,al            ;al <-0x80`
    - CF似乎不受`inc`和`dec`指令的影响？
4. 溢出标志**OF**，假定你进行的是有符号运算，如果结果超出了目标操作数所能容纳的范围，OF=1,否则OF=0.
    - 例如：
        1. `mov ah,0xff     ;ah <- -1`
        2. `add ah,2        ;ah <- 1,因为1没有超出8位有符号数-128~+127范围`
        3. 所以OF=0
    - 例如2：
        1. `mov ah,0x70     ;ah <- +112`
        2. `add ah,ah       ;ah <- +224(DEC)=1110 0000(BIN),但因为224超出了8位有符号数的-128~+127范围，所以1110 0000被解读成-32，计算结果也错误了`
        3. 所以OF=1
        4. 如果想解决这类问题，最好用更大范围的目标操作数，如AX寄存器。
5. Bochs可以查看标志位的状态，书中章节6.12.3
6. 