# 本章学习目标：
1. 新的分段方法，从另一个不同的角度理解处理器的分段内存访问机制。
2. 在计算机中，指令的执行并非总是按照它们的自然排列顺序来进行的，其执行流程也会因为各种原因发生变化
    两种非顺序的程序流程控制方法：
        - 循环
        - 条件转移
3. 新指令：`movsb`,`movsw`,`inc`,`dec`,`cld`,`std`,`div`,`neg`,`cbw`,`cwd`,`sub`,`idiv`,`jcxz`,`cmp`等
4. 认识**INTEL8086**标志寄存器FLAGS的各个标志位，了解条件转移指令。
5. 认识计算机中的负数。
6. 学习**Bochs**调试程序的更多技巧，包括查看**FLAGS**寄存器各标志位的状态。

# 困惑与问题：
1. `jmp near start`中，机器指令的操作码是0xE9，操作数是一个16位的相对偏移量，称为相对近转移。  
2. 主引导程序中，需要访问内存的指令很多，如果要加上0x7c00会很麻烦，我们可以把逻辑地址0x0000：0x7c00对应的物理
地址0x07c00写成段0x07c0，偏移地址为0x0000的逻辑地址。我们的程序会用到该512个字节的区域，看成一个单独的段。该段最大长度可以是64KB，但我们在这里只会用到512字节。
3. 段之间需要批量传送数据时，可以用`movsb`（按字节）和`movsw`（按字），这两个是复制指令；
    - 这两个指令执行时原始数据串的段地址由**DS**指定，偏移地址由**SI**指定，一般简写成**DS:SI**;
    - 目的地址由**ES:DI**指定；
    - 传送的字节数或字数由CX指定；
    - 正向传送：正向就是指从内存区域的低地址端到高地址端，每传送一个字节或一个字，**SI**和**DI**都会加1或者加2；
    - 反向传送：指从内存区域的高地址端到低地址端，每传送一个字节或一个字，**SI**和**DI**都会减1或者减2；
    - 传送次数：不论传送的方向是正向还是反向、传送的是大小一个字节还是一个字，只要每传送一次，CX的内容都会减1；
4. 标志寄存器FLAGS：
    - `cld`是方向标志清零指令，不需要操作数。cld指令将**DF标志**清零，以指示传送方向是正向；
    - `std`将DF标志置位（1），传送方向是从高地址到低地址；
5. `rep`操作码是**0xF3 0xA5**，代码可以写作`rep movsw`；
6. `number`标号初始化5个字节的目的是为了保存数位
7. 8086处理器上，如果**要用寄存器来提供偏移地址，只能使用BX、SI、DI、BP**，不能使用其他的寄存器；
8. 寄存器的知识点
    - AX是累加器，（Accumulator）与它有关的指令还会做指令长度上的优化（较短）；
    - CX是计数器（Counter）；
    - DX是数据寄存器，除了作为通用寄存器使用外，还专门用于和外设之间进行数据传送操作；
    - SI是源索引寄存器（Source Index）；
    - DI是目标索引寄存器（Destination Index)，用于数据传送操作；
9. 可以在任何带有内存操作数的指令中使用**BX、SI或DI**提供偏移地址。
10. `dec`指令用于将目标操作数的内容减1，格式与`inc`相同。  
11. 例如`1000 0000~1111 1111`这些负数，都是用0减去它们相对应的正数得到的。  
    - `1000 0000~1111 1111`这个范围内的有符号数，对应着十进制数`-128~-1`。
        - 例如我们想知道-128（DEC）与-1（DEC）的二进制：  
            - `0-128 = 1000 0000(二进制-128)`
            - `0-1 = 1111 1111（二进制的-1）`  
        - 我们还可以根据“负数的负数”是正数，用0减去这个负数得到正数：  
            - `0000 0000-1000 0000 = 1000 0000（十进制128)`
            - `0000 0000-1111 1111 = 0000 0001（十进制1）`
12. **8086**处理器中，`neg`指令（的功能是用0减去指令中的操作数）所以它的代码格式必须带有一个操作数：
    - 可以是8位或者16位的寄存器，
        `neg al`
        `neg dx`
    - 或内存单元，
        `neg word [label_a]`
13. 有符号数的运算环境
    - **16**位的字，
        - 正数范围是`0000 0000 0000 0000 ~ 0111 1111 1111 1111`，即十进制的**0~32767**；
        - 负数范围是`1000 0000 0000 0000~1111 1111 1111 1111`，即十进制的`-32768~-1`
    - **8**位，
        - 正数范围是`0000 0000 ~ 0111 1111`，即十进制的**0~127**；
        - 负数范围是`1000 0000 ~ 1111 1111`，即十进制的`-128~-1`；
14. 如果给一个8位寄存器传送了一个超出它范围的立即数，超出的位数会被截断。
    - 被截断：例如`mov al,-200`,机器码就是`b0 38`;
    - 在16位寄存器中：`mov ax,-200`机器码是`66 b8 38 ff`；
15. 将8位的有符号数中“辨别符号的那一位”拓展到高8位的指令：
    - `cbw`（Convert Byte to Word），没有操作数，操作码是98：将寄存器AL中的有符号数拓展到整个AX
        - 若al中的内容是`0100 1111`那么执行指令后：AX的内容为`0000 0000 0100 1111`；
    - `cwd`（Convert Word to Double-word），也没有操作数，操作码是99：将寄存器AX中的有符号数拓展到DX:AX
        - 若ax中的内容是`0100 1111 0111 1001`，执行指令后，DX中的内容是`0000 0000 0000 0000`,AX中的内容不变。
        - 若ax中的内容是`1100 1111 0111 1001`，执行指令后，DX中的内容是`1111 1111 1111 1111`,AX中的内容不变。
16. 一个值它是无符号数还是有符号数，取决于我们怎么看待它，不管对他进行`inc`抑或是`add 操作数`，都要以统一的视角(当把0x8c03看作是有符号数时，也要把0x05看作是有符号数）：
    - `mov ax,0x8c03`
    - `add ax,0x05`
17. `sub`指令本质上是对目的操作数进行`neg`操作后，让源操作数与`neg`后的目的操作数进行一次`add`指令。
    - `sub`指令：
        - 目的操作数可以是**8**位或**16**位通用寄存器，也可以是**8**位或**16**位的内存单元；
        - 源操作数可以是通用寄存器，也可以是内存单元或立即数（不允许两个操作数同时为内存单元）
18. `div`是无符号除法指令
19. `idiv`是有符号除法指令，记住：如果结果不要超出寄存器所能表示的范围，可以用32位的除法解决超出范围的问题。
20. INTEL8086处理器只允许以下几种基址寄存器和变址寄存器的组合：
    `[bx+si]    [bx+di]     [bp+si]     [bp+di]`  
21. `jns show`指令：处理器在执行jns命令时要参考标志寄存器的**SF**位。如果未设置符号位，处理器会将SF位清“0”，则转移到标号“show”所在位置处执行。
    - 如果有设置符号位，处理器会将SF位置“1”，则忽略当前`jns`指令，直接向下执行程序。如果没有设置符号位，则返回到标号show处向下执行程序。在`c05_mbr.asm`程序中，`dec`命令会影响符号位的变化（请看`# 程序结构`第8点）。
22.

# 程序结构：
1. 相对近转移指令（因为我们在程序的开头会声明一些数据，我们可以相对近转移指令跳过它们）；
2. 定义一个存放字符串的数据区（需要显示它们的时候，再用指令取出来，将它们一个一个地传送到显示缓冲区）；
3. 将0x7c0设置为数据段基地址，将0xb800设置为附加段基地址，（0xb800所在的段是显示缓冲区）；
4. 方向标志清零指令`cld`，指示传送方向为正；
5. 这一步是设置批量传送数据的出发地点：将标号**mytext**的汇编地址（偏移地址）传送到**SI**寄存器；
6. 这一步是设置批量传送数据的目的地：将偏移地址0传送到**DI**寄存器，这将是附加段寄存器的首偏移地址，也就是逻辑地址地址0xb800:0000，物理地址0xb8000。
7. 我们知道这些需要批量传送的数据是在两个先后紧密相连的标号——“number”与“mytext”之间声明的，而且这两个标号代表的是汇编地址。
    - 在汇编语言里，将后声明的标号作为被减数，先声明的标号作为减数，得出的结果就是mytext中声明的数据的字节数（因为我们声明时用的是`db`，我们在之后的步骤可以每次传送两个字节——也就是一个字的大小，所以我们的总传送次数可以这么表达：`(start-mytext)/2=总共需要传送的次数`，总共需要传送的次数放在寄存器CX就行了。它会在每次传送后给自己减1，当它是0时，便不再传送数据。
    - `rep`指令的意思是**repeat**，意思是CX不为零则重复。
8. 将`number`的汇编地址传送到寄存器AX，以便我们获取`number`处声明的数位在内存段中的偏移地址。
    1. 我们会先将汇编地址复制到寄存器AX，再通过AX复制到寄存器BX
    2. 与此同时将循环次数设置成5（number声明的5个数位，代表我需要将它分解5次）也就是`mov cx,5`；
    3. 设置好除数，`mov si,10`
    4. 另起一行，标号为`digit:`
        1. 将寄存器dx归零
        2. 做完除法后，将dl中的余数传送到bx所指示的内存单元（这就是ax复制number的汇编地址给bx的原因），记住段地址仍是ds，该指令是`mov [bx],dl`;
        3. `inc bx`，给bx的值+1，为number当时声明的下一个数位的偏移地址做准备；
        4. `loop digit`当前CX的值为0吗？
            - cx != 0 时：cx= cx-1，且重复这个标号下的步骤；
            - cx = 0 时：忽略这个`loop digit`指令，执行程序后面的指令。 
9. 将`number`的汇编地址传送到寄存器BX，将立即数4传送给寄存器si
    1. 声明标号show
    2. 将number的汇编地址与立即数4相加的和作为偏移地址，将DS段（0x7c0:number+4)中的数据传送给al寄存器。
    3. 将al寄存器中的值加上`0x30`，作为ASCII字符。这个值大小是字节
    4. 复制`0x04`到ah寄存器，这个值用于字符显示的颜色属性，这个值大小是字节
    5. 将以上两个字节（刚好凑成一个字的大小）的数据传送到我们的显示缓冲区（es：di，也就是0xb800:0000）,指令是`mov [es:di],ax
    6. 以上传送完成后，给偏移地址di的值+2，
    7. `dec`命令给si寄存器的值-1，使得下一次的`[bx+si]`指向的值向存取了更小的位数的值的地址移动。
    8. `jns show`在`dec`命令后，这里会检查si寄存器的值有无设置符号位，
        - 当`dec`后，si寄存器的值成为**3**，二进制为**0000 0011**，没有出现符号位，程序跳转到标号show的位置向下执行；
        - 当`dec`后,si寄存器的值成为`-1`时，出现了符号位，`jns show`命令就不执行；