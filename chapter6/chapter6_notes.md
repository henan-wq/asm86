# 本章学习目标：
1. 新的分段方法，从另一个不同的角度理解处理器的分段内存访问机制。
2. 在计算机中，指令的执行并非总是按照它们的自然排列顺序来进行的，其执行流程也会因为各种原因发生变化
    两种非顺序的程序流程控制方法：
        - 循环
        - 条件转移
3. 新指令：`movsb`,`movsw`,`inc`,`dec`,`cld`,`std`,`div`,`neg`,`cbw`,`cwd`,`sub`,`idiv`,`jcxz`,`cmp`等
4. 认识**INTEL8086**标志寄存器FLAGS的各个标志位，了解条件转移指令。
5. 认识计算机中的负数。
6. 学习**Bochs**调试程序的更多技巧，包括查看**FLAGS**寄存器各标志位的状态。

# 困惑与问题：
1. `jmp near start`中，机器指令的操作码是0xE9，操作数是一个16位的相对偏移量，称为相对近转移。  
2. 主引导程序中，需要访问内存的指令很多，如果要加上0x7c00会很麻烦，我们可以把逻辑地址0x0000：0x7c00对应的物理
地址0x07c00写成段0x07c0，偏移地址为0x0000的逻辑地址。我们的程序会用到该512个字节的区域，看成一个单独的段。该段最大长度可以是64KB，但我们在这里只会用到512字节。
3. 段之间需要批量传送数据时，可以用`movsb`（按字节）和`movsw`（按字），这两个是复制指令；
    - 这两个指令执行时原始数据串的段地址由**DS**指定，偏移地址由**SI**指定，一般简写成**DS:SI**;
    - 目的地址由**ES:DI**指定；
    - 传送的字节数或字数由CX指定；
    - 正向传送：正向就是指从内存区域的低地址端到高地址端，每传送一个字节或一个字，**SI**和**DI**都会加1或者加2；
    - 反向传送：指从内存区域的高地址端到低地址端，每传送一个字节或一个字，**SI**和**DI**都会减1或者减2；
    - 传送次数：不论传送的方向是正向还是反向、传送的是大小一个字节还是一个字，只要每传送一次，CX的内容都会减1；
4. 标志寄存器FLAGS：
    - `cld`是方向标志清零指令，不需要操作数。cld指令将**DF标志**清零，以指示传送方向是正向；
    - `std`将DF标志置位（1），传送方向是从高地址到低地址；
5. `rep`操作码是**0xF3 0xA5**，代码可以写作`rep movsw`；
6. `number`标号初始化5个字节的目的是为了保存数位
7. 8086处理器上，如果**要用寄存器来提供偏移地址，只能使用BX、SI、DI、BP**，不能使用其他的寄存器；
8. 寄存器的知识点
    - AX是累加器，（Accumulator）与它有关的指令还会做指令长度上的优化（较短）；
    - CX是计数器（Counter）；
    - DX是数据寄存器，除了作为通用寄存器使用外，还专门用于和外设之间进行数据传送操作；
    - SI是源索引寄存器（Source Index）；
    - DI是目标索引寄存器（Destination Index)，用于数据传送操作；
9. 可以在任何带有内存操作数的指令中使用**BX、SI或DI**提供偏移地址。
10. `dec`指令用于将目标操作数的内容减1，格式与`inc`相同。  


# 程序结构：
1. 相对近转移指令（因为我们在程序的开头会声明一些数据，我们可以相对近转移指令跳过它们）；
2. 定义一个存放字符串的数据区（需要显示它们的时候，再用指令取出来，将它们一个一个地传送到显示缓冲区）；
3. 将0x7c0设置为数据段基地址，将0xb800设置为附加段基地址，（0xb800所在的段是显示缓冲区）；
4. 方向标志清零指令`cld`，指示传送方向为正；
5. 这一步是设置批量传送数据的出发地点：将标号**mytext**的汇编地址（偏移地址）传送到**SI**寄存器；
6. 这一步是设置批量传送数据的目的地：将偏移地址0传送到**DI**寄存器，这将是附加段寄存器的首偏移地址，也就是逻辑地址地址0xb800:0000，物理地址0xb8000。
7. 我们知道这些需要批量传送的数据是在两个先后紧密相连的标号——“number”与“mytext”之间声明的，而且这两个标号代表的是汇编地址。
    - 在汇编语言里，将后声明的标号作为被减数，先声明的标号作为减数，得出的结果就是mytext中声明的数据的字节数（因为我们声明时用的是`db`，我们在之后的步骤可以每次传送两个字节——也就是一个字的大小，所以我们的总传送次数可以这么表达：`(start-mytext)/2=总共需要传送的次数`，总共需要传送的次数放在寄存器CX就行了。它会在每次传送后给自己减1，当它是0时，便不再传送数据。
    - `rep`指令的意思是**repeat**，意思是CX不为零则重复。
8. 将`number`的汇编地址传送到寄存器AX，以便我们获取`number`处声明的数位在内存段中的偏移地址。
    1. 我们会先将汇编地址复制到寄存器AX，再通过AX复制到寄存器BX
    2. 与此同时将循环次数设置成5（number声明的5个数位，代表我需要将它分解5次）也就是`mov cx,5`；
    3. 设置好除数，`mov si,10`
    4. 另起一行，标号为`digit:`
        1. 将寄存器dx归零
        2. 做完除法后，将dl中的余数传送到bx所指示的内存单元（这就是ax复制number的汇编地址给bx的原因），记住段地址仍是ds，该指令是`mov [bx],dl`;
        3. `inc bx`，给bx的值+1，为number当时声明的下一个数位的偏移地址做准备；
        4. `loop digit`当前CX的值为0吗？
            - cx != 0 时：cx= cx-1，且重复这个标号下的步骤；
            - cx = 0 时：忽略这个`loop digit`指令，执行程序后面的指令。 